/**
 * Export utilities for study tools
 * Implements PDF and DOCX export functionality
 */

import type { StudyToolContent } from './study-tools-store'

/**
 * Generate PDF from study tool content
 */
export async function exportToPDF(content: StudyToolContent): Promise<void> {
  try {
    // Create a clean HTML version of the content
    const htmlContent = formatContentForExport(content)

    // Create a new window for printing
    const printWindow = window.open('', '_blank')

    if (!printWindow) {
      throw new Error('Popup blocked. Please allow popups and try again.')
    }

    // Inject styled HTML
    printWindow.document.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>${content.title}</title>
          <style>
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }

            body {
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              line-height: 1.6;
              color: #1f2937;
              max-width: 800px;
              margin: 0 auto;
              padding: 40px 20px;
              background: white;
            }

            h1 {
              font-size: 2.5rem;
              font-weight: 700;
              margin-bottom: 1rem;
              color: #111827;
              border-bottom: 3px solid #14b8a6;
              padding-bottom: 0.5rem;
            }

            h2 {
              font-size: 1.875rem;
              font-weight: 600;
              margin: 2rem 0 1rem 0;
              color: #374151;
            }

            h3 {
              font-size: 1.5rem;
              font-weight: 600;
              margin: 1.5rem 0 0.75rem 0;
              color: #4b5563;
            }

            h4 {
              font-size: 1.25rem;
              font-weight: 600;
              margin: 1.25rem 0 0.5rem 0;
              color: #6b7280;
            }

            h5, h6 {
              font-size: 1.125rem;
              font-weight: 600;
              margin: 1rem 0 0.5rem 0;
              color: #6b7280;
            }

            p {
              margin-bottom: 1rem;
              text-align: justify;
            }

            ul, ol {
              margin: 1rem 0;
              padding-left: 2rem;
            }

            li {
              margin-bottom: 0.5rem;
            }

            strong {
              font-weight: 600;
              color: #111827;
            }

            em {
              font-style: italic;
              color: #374151;
            }

            code {
              background: #f3f4f6;
              padding: 0.25rem 0.5rem;
              border-radius: 0.25rem;
              font-family: 'JetBrains Mono', Consolas, monospace;
              font-size: 0.875rem;
            }

            pre {
              background: #f9fafb;
              border: 1px solid #e5e7eb;
              border-radius: 0.5rem;
              padding: 1rem;
              margin: 1rem 0;
              overflow-x: auto;
            }

            blockquote {
              border-left: 4px solid #14b8a6;
              background: #f0fdfa;
              padding: 1rem 1.5rem;
              margin: 1rem 0;
              font-style: italic;
            }

            .metadata {
              background: #f9fafb;
              border: 1px solid #e5e7eb;
              border-radius: 0.5rem;
              padding: 1rem;
              margin-bottom: 2rem;
              font-size: 0.875rem;
              color: #6b7280;
            }

            .page-break {
              page-break-before: always;
            }

            @media print {
              body {
                max-width: none;
                margin: 0;
                padding: 20px;
              }

              .no-print {
                display: none;
              }

              h1, h2, h3 {
                page-break-after: avoid;
              }

              ul, ol {
                page-break-inside: avoid;
              }
            }
          </style>
        </head>
        <body>
          <div class="metadata">
            <strong>Generated:</strong> ${new Date().toLocaleString()}<br>
            <strong>Type:</strong> ${getToolDisplayName(content.type)}<br>
            <strong>Source:</strong> ${content.title}
          </div>
          ${htmlContent}
          <div class="no-print" style="margin-top: 2rem; text-align: center; color: #9ca3af; font-size: 0.875rem;">
            Generated by CogniLeapAI â€¢ ${new Date().toLocaleDateString()}
          </div>
        </body>
      </html>
    `)

    printWindow.document.close()

    // Wait for content to load then trigger print
    printWindow.onload = () => {
      setTimeout(() => {
        printWindow.print()
        printWindow.close()
      }, 250)
    }

  } catch (error) {
    console.error('PDF export failed:', error)
    throw new Error('Failed to generate PDF. Please try again.')
  }
}

/**
 * Generate DOCX from study tool content
 */
export async function exportToDOCX(content: StudyToolContent): Promise<void> {
  try {
    // For now, we'll use a simple approach that creates a downloadable text file
    // In a production environment, you'd want to use a library like docx.js

    const textContent = formatContentForText(content)
    const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' })

    // Create download link
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `${sanitizeFilename(content.title)}.txt`

    // Trigger download
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)

    // Clean up
    URL.revokeObjectURL(url)

  } catch (error) {
    console.error('DOCX export failed:', error)
    throw new Error('Failed to generate document. Please try again.')
  }
}

/**
 * Format content for HTML export
 */
function formatContentForExport(content: StudyToolContent): string {
  let html = `<h1>${content.title}</h1>\n\n`

  // Convert markdown-like content to HTML
  const lines = content.content.split('\n')
  let inCodeBlock = false
  let inList = false

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]

    // Handle code blocks
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        html += '</pre>\n'
        inCodeBlock = false
      } else {
        html += '<pre><code>'
        inCodeBlock = true
      }
      continue
    }

    if (inCodeBlock) {
      html += escapeHtml(line) + '\n'
      continue
    }

    // Handle headings
    if (line.startsWith('#')) {
      if (inList) {
        html += '</ul>\n'
        inList = false
      }

      const level = (line.match(/^#+/) || [''])[0].length
      const text = line.replace(/^#+\s*/, '')
      html += `<h${Math.min(level, 6)}>${escapeHtml(text)}</h${Math.min(level, 6)}>\n`
      continue
    }

    // Handle bullet points
    if (line.match(/^\s*[-*+]\s/)) {
      if (!inList) {
        html += '<ul>\n'
        inList = true
      }
      const text = line.replace(/^\s*[-*+]\s*/, '')
      html += `<li>${formatInlineContent(text)}</li>\n`
      continue
    }

    // Handle numbered lists
    if (line.match(/^\s*\d+\.\s/)) {
      if (!inList) {
        html += '<ol>\n'
        inList = true
      }
      const text = line.replace(/^\s*\d+\.\s*/, '')
      html += `<li>${formatInlineContent(text)}</li>\n`
      continue
    }

    // Handle empty lines
    if (line.trim() === '') {
      if (inList) {
        html += '</ul>\n'
        inList = false
      }
      html += '\n'
      continue
    }

    // Handle regular paragraphs
    if (inList) {
      html += '</ul>\n'
      inList = false
    }

    html += `<p>${formatInlineContent(line)}</p>\n`
  }

  // Close any open lists
  if (inList) {
    html += '</ul>\n'
  }

  if (inCodeBlock) {
    html += '</code></pre>\n'
  }

  return html
}

/**
 * Format content for text export
 */
function formatContentForText(content: StudyToolContent): string {
  const separator = '='.repeat(80)

  return `${separator}
${content.title.toUpperCase()}
${separator}

Generated: ${new Date().toLocaleString()}
Type: ${getToolDisplayName(content.type)}

${separator}

${content.content}

${separator}
Generated by CogniLeapAI
${new Date().toLocaleDateString()}
${separator}`
}

/**
 * Format inline content (bold, italic, code)
 */
function formatInlineContent(text: string): string {
  return text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/`(.*?)`/g, '<code>$1</code>')
    .replace(/\n/g, '<br>')
}

/**
 * Escape HTML characters
 */
function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

/**
 * Get display name for tool type
 */
function getToolDisplayName(type: string): string {
  const names = {
    'study-guide': 'Study Guide',
    'smart-summary': 'Smart Summary',
    'smart-notes': 'Smart Notes',
    'flashcards': 'Flashcards'
  }
  return names[type as keyof typeof names] || type
}

/**
 * Sanitize filename for download
 */
function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-zA-Z0-9\s\-_]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 100)
}